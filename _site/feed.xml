<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clapwatermelon</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Fri, 06 Apr 2018 22:47:07 +0900</pubDate>
    
      <item>
        <title>Operating Systems 1 - Computer Organization</title>
        <link>/2018/04/06/Operating-Systems.html</link>
        <guid isPermaLink="true">/2018/04/06/Operating-Systems.html</guid>
        <description>&lt;h2 id=&quot;what-is-an-operating-system&quot;&gt;What is an Operating System?&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;Help the user use computer easily (Interface)&lt;/li&gt;
  &lt;li&gt;Help the software use computer resource&lt;/li&gt;
  &lt;li&gt;Help the programmer develop software (API)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;OS : software와 hardware 사이의 소통을 도움&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;von-neumann-machine&quot;&gt;Von Neumann Machine&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-Von-Neumann Machine:
    &lt;ul&gt;
      &lt;li&gt;A computer can do only single computation&lt;/li&gt;
      &lt;li&gt;Program = HW, Data in memory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Von-Neumann Machine
    &lt;ul&gt;
      &lt;li&gt;General purpose computer&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Program in memory&lt;/strong&gt;, Data in memory&lt;/li&gt;
      &lt;li&gt;Called stored-program architecture&lt;/li&gt;
      &lt;li&gt;Good: re=program easily&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전의 폰노이만 머신에서는 프로그램은 하드웨어에, 데이터는 메모리에 따로 존재했었다면 폰 노이만 머신에서는 프로그램과 데이터가 메모리 안에 들어감으로써 프로그램을 좀 더 쉽게 할 수 있게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/VNA.png&quot; alt=&quot;VNA&quot; title=&quot;Von Neumann Architecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;registers&quot;&gt;Registers&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;입출력(I/O)을 위한 저장공간
&lt;img src=&quot;/assets/post_img/Registers.png&quot; alt=&quot;Registers&quot; title=&quot;Registers&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Program Counter: 다음 수행할 명령어가 어디인지 주소를 저장&lt;/li&gt;
  &lt;li&gt;Instruction Register: 현재 실행하고 있는 명령어&lt;/li&gt;
  &lt;li&gt;MBR:가져온 주소로 가서 data를 넣음&lt;/li&gt;
  &lt;li&gt;MAR: 가져온 주소를 써 놓는 곳&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problem-1-of-von-neumann&quot;&gt;Problem 1 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Von Neumann Bottleneck = Bus&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Too much to move over bus: slow (좋은 CPU 여도 Bus도 좋아야 빠르다)
Solution: Cache&lt;/li&gt;
  &lt;li&gt;Temporary fast memory with recent data/program&lt;/li&gt;
  &lt;li&gt;Code optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bus에 병목현상이 생기는 문제점을 일시적으로 최근 데이터를 Cache에 저장&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;problem-2-of-von-neumann&quot;&gt;Problem 2 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Program &amp;amp; Data in same memory&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A program can mess-up instructions in memory
Solution: Harvard Architecture&lt;/li&gt;
  &lt;li&gt;Separate data and program memory&lt;/li&gt;
  &lt;li&gt;Memory restriction: Prevent accessing memory outside data&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;program과 data가 같은 메모리안에 있게되면 data에 접근할 때 program도 접근이 가능하여 안정성이나 보안도 떨어지게 되고 또한 프로그램은 메모리에 엉망인 명령들을 내려 망가뜨릴 수 있는 가능성이 있다. 아래의 이미지를통해 폰노이만과 하버드의 구조적 차이를 보면 이해가 빠르다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/harvardA.png&quot; alt=&quot;harvardArchitecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-3-of-von-neumann&quot;&gt;Problem 3 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Program &amp;amp; Data over ther same bus&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Different fetch rate, slow bus
Solution: Harvard Architecture&lt;/li&gt;
  &lt;li&gt;Seperate data and program bus&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Problem 2 와 Problem 3 은 같은 문제라고 볼 수 있다. 즉, Program과 Data가 같이 들어있기 때문에 발생된 문제이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;how-a-computer-can-do-many-things-simultaneously&quot;&gt;How a computer can do many things simultaneously?&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Interrupts&lt;/p&gt;

&lt;h3 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Provided to improve processor utilization&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;most I/O devices are slower than the processor&lt;/li&gt;
  &lt;li&gt;processor must pause to wait for device&lt;/li&gt;
  &lt;li&gt;wasterful use of the processor&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려 처리할 수 있도록 하는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;memory-hierarchy&quot;&gt;Memory Hierarchy&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Major constraints in memory&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;amount&lt;/li&gt;
  &lt;li&gt;speed&lt;/li&gt;
  &lt;li&gt;expense
Memory must be able to keep up with the processor
Cost of memory must be reasonable in relationship to the other componets&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;the-memory-hierarchy&quot;&gt;The Memory Hierarchy&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post_img/memoryHierarchy.png&quot; alt=&quot;memoryHierarchy&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위로 갈 수록 빠르고 비쌈, 용량은 적고 속도 빨라짐, 사용 빈도 높아짐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Going down the hierarchy:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;decreasing cost per bit&lt;/li&gt;
  &lt;li&gt;increasing capacity&lt;/li&gt;
  &lt;li&gt;increasing access time&lt;/li&gt;
  &lt;li&gt;decreasing frequency of access to the memory by the processor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Inboard memory:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Registers&lt;/li&gt;
  &lt;li&gt;Cache&lt;/li&gt;
  &lt;li&gt;Main Memory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Outboard Storage:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Magnetic Disk, CD-ROM . .&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;principle-of-locality&quot;&gt;Principle of Locality&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;컴퓨터 프로그램의 메모리 접근 패턴이 시 공간적으로 근접한 모습을 보이는 경향이 크다 이것을 근접성의 원칙이라고 한다.
Fact: Memory references by the processor tend to cluster in time and space&lt;/p&gt;

&lt;p&gt;How to exploit it:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Data is organized so that the percentage of accesses to each successively lower level is substantially less than that of the level above&lt;/li&gt;
  &lt;li&gt;Can be applied across more than two levels of memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache-memory&quot;&gt;Cache memory&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Invisible to the processors, programmer, OS
Interacts with other memory management hardware
Reasons for its existence:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Processor must access memory at least once per instruction cycle&lt;/li&gt;
  &lt;li&gt;Processor execution is limited by memory cycle time&lt;/li&gt;
  &lt;li&gt;Exploit the principle of locality with a small, fast memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/CacheOrganization.png&quot; alt=&quot;Cache&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위 그림에서와 같이 Main memory에서 Block 단위로 가져오는 것을 알 수있다.
동대문에서 옷을 가져와서 팔려할 때 티한장 가져와서 팔고 또 한장 가져와서 팔고 할 수 없으니 통째(Block)로 가져와서 파는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;replacement-algorithm&quot;&gt;Replacement Algorithm&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;캐시에 새로운 Block을 로드할 때 어떤 Block을 대체할 것인지에 대한 알고리즘&lt;/p&gt;

&lt;p&gt;Choose which block to replace when a new block is to be loaded into the cahe&lt;/p&gt;

&lt;p&gt;Least Recently Used(LRU) Algorithm: 가장 최근에 덜 사용 된 것을 대체시키는 알고리즘&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>MVC, MVP, MVVM</title>
        <link>/2018/04/06/MVC-MVP-MVVM.html</link>
        <guid isPermaLink="true">/2018/04/06/MVC-MVP-MVVM.html</guid>
        <description>&lt;p&gt;디자인 패턴이란?
소프트웨어 디자인에서 공통적으로 발생하는 문제를 다루는 보편적이고 반복해서 사용할 수 있는 방법. 이는 다양한 상황에서 사용될 수 있는, 문제를 해결하는 방법에 대한 설명이나 템플릿이다.&lt;/p&gt;

&lt;p&gt;MVC, MVP, MVVM 패턴과 같은 프레임워크가 나오게 된 궁극적인 이유는?
&lt;strong&gt;각 계층을 분리&lt;/strong&gt;시킴으로써 &lt;strong&gt;코드의 재활용성을 높이고 불필요한 중복을 막기위해&lt;/strong&gt;
Model과View의 의존성을 어떻게 제어하느냐에 따라 각 패턴이 분류된다.&lt;/p&gt;

&lt;h2 id=&quot;mvcmodel-view-controller&quot;&gt;MVC(Model-View-Controller)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/MVC.png&quot; alt=&quot;MVC&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든 입력은 Controller로 들어와 처리된다 -&amp;gt; 입력이 Controller로 들어오면 Controller는 입력에 해당하는 Model을 업데이트한다 -&amp;gt; Model은 해당 데이터를 보여줄 View를 선택하여 보여준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Model: 애플리케이션과 관련된 데이터를 캡슐호하고, 해당 데이터를 조작하고 처리하는 로직과 계산을 하는 부분&lt;/p&gt;

&lt;p&gt;View: 애플리케이션 내에서 사용자가 볼 수있는 부분(화면). 사용자 동작에 응답할 수있다.&lt;/p&gt;

&lt;p&gt;Controller: 하나 이상의 애플리케이션 뷰 객체와 하나 이상의 모델 객체 사이의 코디네이터 또는 중개자 역할을 하는 부분. 뷰로 하여금 모델 객체의 변경사항을 인지하거나, 그 반대의 경우가 가능하도록 하는 매개체. 다른 객체들의 life cycle을 관리하기도 한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
