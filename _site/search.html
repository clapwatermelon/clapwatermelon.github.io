<!DOCTYPE html>
<html class="no-js">
  <head>
	<meta charset="utf-8">
	<title>Search | clapwatermelon</title>
	<meta name="description" content="A website with blog posts and pages">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- CSS -->
	<link rel="stylesheet" href="/assets/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

	<!-- Canonical -->
	<link rel="canonical" href="/search.html">

	<!-- RSS -->
	<link rel="alternate" type="application/atom+xml" title="clapwatermelon" href="/feed.xml" />

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
	

	<!-- KaTeX -->
	
	<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script>
	

	<!-- Google Analytics -->
	
	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-117105955-1', 'auto');
	ga('send', 'pageview');
	</script>
	
</head>

  <body>
    <header class="site-header">
	<div class="branding">
		
		<a href="/">
			<img class="avatar" src="/assets/img/watermelon.png" alt=""/>
		</a>
		
		<h1 class="site-title">
			<a href="/">clapwatermelon</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
			
			
			
			
			<li>
				<a class="page-link" href="/about/">
					About
				</a>
			</li>
			
			
			
			
			
			
			
			
			
			
			
			<li>
				<a class="page-link" href="/tags.html">
					tags
				</a>
			</li>
			
			
			<!-- Social icons from Font Awesome, if enabled  -->
			


<li>
	<a href="mailto:clapwatermelon@gmail.com" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>













<li>
	<a href="https://github.com/clapwatermelon" title="Follow on GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>




























            
            <!-- Search bar -->
            
            <li>
            <form action="/search.html" method="get">
                <input type="text" id="search-box" name="query" placeholder="Search" class="">
                <button type="submit" class="">
                    <i class="fa fa-fw fa-search"></i>
                </button>
            </form>
            </li>
            
		</ul>
	</nav>
    
</header>

    <div class="content">
      <article >
  <header style="background-image: url('/')">
    <h1 class="title">Search</h1>
    
  </header>
  <section class="post-content"><div class="search">
    <div id="search-results"></div>
    <p id="not-found" style="display: none">
        No results found.
    </p>
</div>


<script>
  window.store = {
    
      "2018-04-07-operating-systems3-html": {
        "title": "Operating Systems 3 - Process",
        "tags": "multitasking, multiprogramming, multithreading, process, PCB, Process Controll Block, Context Switch, OS, OperatingSystems",
        "date": "April 7, 2018",
        "author": "",
        "category": "",
        "content": "Process?메모리에 올라간 순간부터 프로세스라고 부른다.Multi-programmingRun multiple-programs with timesharing     Run each program in turn until timeout or I/O event  옛날 컴퓨터라고 볼 수 있다MultitaskingMultiprogramming with frequent job switching     CPU scheduling  빨리빨리해서 동시에 시행되는 것처럼 하는 것MultithreadingA process with multiple threadsProcess Control Block(PCB)프로세스 제어 블록(PCB)는 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조. 각 프로세스가 생성될 때마다 고유의 PCB가 생성되고 프로세스가 완료되면 PCB는 제거된다.PCB contains  Process state  Program identifier number (PID)  Program counter (PC)  CPU registers  CPU scheduling information  Memory-management information  Accounting information  I/O status information  프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고 다시 CPU를 점유하여 작업을 수행해야 할 때 PCB로부터 해당 정보들을 CPU에서 넘겨와 계속해서 하던 작업을 진행할 수 있다.Context Switch  운영체제는 멀티태스킹을 위해서 여러 프로세스를 번갈아가면서 수행한다. 이때, 현재 수행중인 프로세스를 중단하고 새로운 프로세스로 전환하는 과정을 context switch 라고 한다. 이 과정에서 PCB를 활용한다.",
        "url": "//2018/04/07/Operating-Systems3.html"
      }
      ,
    
      "2018-04-06-operating-systems2-html": {
        "title": "Operating Systems 2 - Microkernel VS Monolithic kernel",
        "tags": "Microkernel, Monolithic, Kernel",
        "date": "April 6, 2018",
        "author": "",
        "category": "",
        "content": "Microkernel?Moves as much from the kernel into “user” spaceCommunication takes place between user modules using message passingBenefits:  Easier to extend a microkernel  Easier to port the operating system to new architectures  More reliable (less code is running in kernel mode)  More secureDetriments:  Performance overhead of user space to kernel space communication  커널의 크기가 작으므로 커널과 일부 서비스만으로 작은 운영체제를 구성하여 임베디드 시스템에 사용가능. 즉, 컴포넌트 기반 운영체제에 더욱 가깝다고 할 수 있다. 커널의 핵심적인 기능 외에 모두 프로세스 형태로 제공되므로 파일시스템이나 입출력 처리가 많을수록 서로간의 메세지를 주고 받아야하므로 속도가 느려질 수 있다.Monolithic kernel?ModulesMost modern operating systems implement kernel modules  Uses object-oriented approach  Each core componet is separate  Each talks to the others over known interfaces  Each is loadable as needed within the kernelOverall, similar to layers but with more flexible  커널이 많은 일을 한다. 가장 확장성이 떨어지는 방법이지만 성능이 좋아서 리눅스에서도 사용되고 있으며 리눅스는 확장성을 보완하기 위해서 module을 사용한다.Microkernel과 Monolithic kernel을 예를 들자면   정부는 작아야한다! 공화당스러운건 Microkernel (kernel이 작으므로)   정부는 커야한다! 민주당스러운건 Monolithic kernel (kernel이 많은 일을 해야하므로)",
        "url": "//2018/04/06/Operating-Systems2.html"
      }
      ,
    
      "2018-04-06-operating-systems-html": {
        "title": "Operating Systems 1 - Computer Organization",
        "tags": "OperatingSystems, OS",
        "date": "April 6, 2018",
        "author": "",
        "category": "",
        "content": "What is an Operating System?  Help the user use computer easily (Interface)  Help the software use computer resource  Help the programmer develop software (API)  OS : software와 hardware 사이의 소통을 도움Von Neumann Machine  Pre-Von-Neumann Machine:          A computer can do only single computation      Program = HW, Data in memory        Von-Neumann Machine          General purpose computer      Program in memory, Data in memory      Called stored-program architecture      Good: re-program easily        이전의 폰 노이만 머신에서는 프로그램은 하드웨어에, 데이터는 메모리에 따로 존재했었다면 폰 노이만 머신에서는 프로그램과 데이터가 메모리 안에 들어감으로써 프로그램을 좀 더 쉽게 할 수 있게 되었다.Registers입출력(I/O)을 위한 저장공간  Program Counter: 다음 수행할 명령어가 어디인지 주소를 저장  Instruction Register: 현재 실행하고 있는 명령어  MBR:가져온 주소로 가서 data를 넣음  MAR: 가져온 주소를 써 놓는 곳Problem 1 of Von-NeumannProblem: Von Neumann Bottleneck = Bus  Too much to move over bus: slow (좋은 CPU 여도 Bus도 좋아야 빠르다)Solution: Cache  Temporary fast memory with recent data/program  Code optimization  Bus에 병목현상이 생기는 문제점을 일시적으로 최근 데이터를 Cache에 저장Problem 2 of Von-NeumannProblem: Program &amp; Data in same memory  A program can mess-up instructions in memorySolution: Harvard Architecture  Separate data and program memory  Memory restriction: Prevent accessing memory outside data  program과 data가 같은 메모리안에 있게되면 data에 접근할 때 program도 접근이 가능하여 안정성이나 보안도 떨어지게 되고 또한 프로그램은 메모리에 엉망인 명령들을 내려 망가뜨릴 수 있는 가능성이 있다. 아래의 이미지를통해 폰노이만과 하버드의 구조적 차이를 보면 이해가 빠르다.Problem 3 of Von-NeumannProblem: Program &amp; Data over ther same bus  Different fetch rate, slow busSolution: Harvard Architecture  Seperate data and program bus  Problem 2 와 Problem 3 은 같은 문제라고 볼 수 있다. 즉, Program과 Data가 같이 들어있기 때문에 발생된 문제이다.How a computer can do many things simultaneously?Interrupts!! 컴퓨터가 동시에 여러가지 일을 할 수 있도록 해주는 기능InterruptsProvided to improve processor utilization  most I/O devices are slower than the processor  processor must pause to wait for device  wasterful use of the processor  CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려 처리할 수 있도록 하는 것Memory HierarchyMemoryMajor constraints in memory  amount  speed  expenseMemory must be able to keep up with the processorCost of memory must be reasonable in relationship to the other componetsThe Memory Hierarchy  위로 갈 수록 빠르고 비쌈, 용량은 적고 속도 빨라짐, 사용 빈도 높아짐Going down the hierarchy:  decreasing cost per bit  increasing capacity  increasing access time  decreasing frequency of access to the memory by the processorInboard memory:  Registers  Cache  Main MemoryOutboard Storage:  Magnetic Disk, CD-ROM . .Principle of Locality컴퓨터 프로그램의 메모리 접근 패턴이 시 공간적으로 근접한 모습을 보이는 경향이 크다 이것을 근접성의 원칙이라고 한다.Fact: Memory references by the processor tend to cluster in time and spaceHow to exploit it:  Data is organized so that the percentage of accesses to each successively lower level is substantially less than that of the level above  Can be applied across more than two levels of memoryCache memoryInvisible to the processors, programmer, OSInteracts with other memory management hardwareReasons for its existence:  Processor must access memory at least once per instruction cycle  Processor execution is limited by memory cycle time  Exploit the principle of locality with a small, fast memory  위 그림에서와 같이 Main memory에서 Block 단위로 가져오는 것을 알 수있다.동대문에서 옷을 가져와서 팔려할 때 티한장 가져와서 팔고 또 한장 가져와서 팔고 할 수 없으니 통째(Block)로 가져와서 파는 것Replacement Algorithm캐시에 새로운 Block을 로드할 때 어떤 Block을 대체할 것인지에 대한 알고리즘  Choose which block to replace when a new block is to be loaded into the cahe  Least Recently Used(LRU) Algorithm: 가장 최근에 덜 사용 된 것을 대체시키는 알고리즘",
        "url": "//2018/04/06/Operating-Systems.html"
      }
      ,
    
      "2018-04-06-mvc-mvp-mvvm-html": {
        "title": "MVC, MVP, MVVM",
        "tags": "MVC, MVP, MVVM",
        "date": "April 6, 2018",
        "author": "",
        "category": "",
        "content": "디자인 패턴이란?소프트웨어 디자인에서 공통적으로 발생하는 문제를 다루는 보편적이고 반복해서 사용할 수 있는 방법. 이는 다양한 상황에서 사용될 수 있는, 문제를 해결하는 방법에 대한 설명이나 템플릿이다.MVC, MVP, MVVM 패턴과 같은 프레임워크가 나오게 된 궁극적인 이유는?각 계층을 분리시킴으로써 코드의 재활용성을 높이고 불필요한 중복을 막기위해 각 패턴들은 Model과 View의 의존성을 어떻게 제어하느냐에 따라 분류된다.MVC(Model-View-Controller)  모든 입력은 Controller로 들어와 처리된다 -&gt; 입력이 Controller로 들어오면 Controller는 입력에 해당하는 Model을 업데이트한다 -&gt; Model은 해당 데이터를 보여줄 View를 선택하여 보여준다.Model: 애플리케이션과 관련된 데이터를 캡슐화하고, 해당 데이터를 조작하고 처리하는 로직과 계산을 하는 부분View: 애플리케이션 내에서 사용자가 볼 수있는 부분(화면). 사용자 동작에 응답할 수있다.Controller: 하나 이상의 애플리케이션 뷰 객체와 하나 이상의 모델 객체 사이의 코디네이터 또는 중개자 역할을 하는 부분. 뷰로 하여금 모델 객체의 변경사항을 인지하거나, 그 반대의 경우가 가능하도록 하는 매개체. 다른 객체들의 life cycle을 관리하기도 한다.",
        "url": "//2018/04/06/MVC-MVP-MVVM.html"
      }
      
    
  };
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/0.7.1/lunr.min.js"></script>
<script src="/assets/js/search.js"></script>
</section>
</article>

    </div>
    
<script src="/assets/js/katex_init.js"></script>



<footer class="site-footer">
	<p class="text">Written by suhyun Park
</p>
</footer>


    <script id="dsq-count-scr" src="//clapwatermelon-github-io.disqus.com/count.js" async></script>
  </body>
</html>
