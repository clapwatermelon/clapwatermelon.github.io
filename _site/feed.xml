<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>clapwatermelon</title>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <link>http://localhost:4000/</link>
    <description>A website with blog posts and pages</description>
    <pubDate>Sat, 07 Apr 2018 01:25:01 +0900</pubDate>
    
      <item>
        <title>Operating Systems 3 - Process</title>
        <link>/2018/04/07/Operating-Systems3.html</link>
        <guid isPermaLink="true">/2018/04/07/Operating-Systems3.html</guid>
        <description>&lt;h2 id=&quot;process&quot;&gt;Process?&lt;/h2&gt;
&lt;p&gt;메모리에 올라간 순간부터 프로세스라고 부른다.&lt;/p&gt;
&lt;h3 id=&quot;multi-programming&quot;&gt;Multi-programming&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Run multiple-programs with &lt;strong&gt;timesharing&lt;/strong&gt;
Run each program in turn until &lt;strong&gt;timeout&lt;/strong&gt; or &lt;strong&gt;I/O event&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;옛날 컴퓨터라고 볼 수 있다&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;multitasking&quot;&gt;Multitasking&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Multiprogramming with frequent job switching
CPU scheduling&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;빨리빨리해서 동시에 시행되는 것처럼 하는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;multithreading&quot;&gt;Multithreading&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;A process with multiple threads&lt;/p&gt;

&lt;h2 id=&quot;process-control-blockpcb&quot;&gt;Process Control Block(PCB)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;프로세스 제어 블록(PCB)는 특정한 프로세스를 관리할 필요가 있는 정보를 포함하는 운영체제 커널의 자료구조. &lt;strong&gt;각 프로세스가 생성될 때마다 고유의 PCB&lt;/strong&gt;가 생성되고 프로세스가 완료되면 PCB는 제거된다.&lt;/p&gt;
&lt;h3 id=&quot;pcb-contains&quot;&gt;PCB contains&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Process state&lt;/li&gt;
  &lt;li&gt;Program identifier number (PID)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://clapwatermelon.github.io/2018/04/06/Operating-Systems.html&quot;&gt;Program counter&lt;/a&gt; (PC)&lt;/li&gt;
  &lt;li&gt;CPU registers&lt;/li&gt;
  &lt;li&gt;CPU scheduling information&lt;/li&gt;
  &lt;li&gt;Memory-management information&lt;/li&gt;
  &lt;li&gt;Accounting information&lt;/li&gt;
  &lt;li&gt;I/O status information&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로세스는 CPU가 처리하던 작업의 내용들을 자신의 PCB에 저장하고 다시 CPU를 점유하여 작업을 수행해야 할 때 PCB로부터 해당 정보들을 CPU에서 넘겨와 계속해서 하던 작업을 진행할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;context-switch&quot;&gt;Context Switch&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post_img/contextSwitch.png&quot; alt=&quot;contextSwitch&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;운영체제는 멀티태스킹을 위해서 여러 프로세스를 번갈아 가면서 수행한다. 이때, 현재 수행중인 프로세스를 중단하고 새로운 프로세스로 전환하는 과정을 &lt;strong&gt;context switch&lt;/strong&gt; 라고 한다. 이 과정에서 PCB를 활용한다.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sat, 07 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Operating Systems 2 - Microkernel VS Monolithic kernel</title>
        <link>/2018/04/06/Operating-Systems2.html</link>
        <guid isPermaLink="true">/2018/04/06/Operating-Systems2.html</guid>
        <description>&lt;h2 id=&quot;microkernel&quot;&gt;Microkernel?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;Moves as much from the kernel into “user” space&lt;br /&gt;
Communication takes place between user modules using message passing&lt;/p&gt;

&lt;p&gt;Benefits:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Easier to extend a microkernel&lt;/li&gt;
  &lt;li&gt;Easier to port the operating system to new architectures&lt;/li&gt;
  &lt;li&gt;More &lt;strong&gt;reliable&lt;/strong&gt; (less code is running in kernel mode)&lt;/li&gt;
  &lt;li&gt;More &lt;strong&gt;secure&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Detriments:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Performance overhead of user space to kernel space communication&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;커널의 크기가 작으므로 커널과 일부 서비스만으로 작은 운영체제를 구성하여 임베디드 시스템에 사용가능. 즉, 컴포넌트 기반 운영체제에 더욱 가깝다고 할 수 있다. 커널의 핵심적인 기능 외에 모두 프로세스 형태로 제공되므로 파일시스템이나 입출력 처리가 많을수록 서로간의 메세지를 주고 받아야하므로 속도가 느려질 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;monolithic-kernel&quot;&gt;Monolithic kernel?&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Modules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Most modern operating systems implement kernel modules&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Uses &lt;strong&gt;object-oriented&lt;/strong&gt; approach&lt;/li&gt;
  &lt;li&gt;Each core &lt;strong&gt;componet is separate&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Each talks to the others over known interfaces&lt;/li&gt;
  &lt;li&gt;Each is &lt;strong&gt;loadable as needed within the kernel&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Overall, similar to layers but with more flexible&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;커널이 많은 일을 한다. 가장 확장성이 떨어지는 방법이지만 성능이 좋아서 리눅스에서도 사용되고 있으며 리눅스는 확장성을 보완하기 위해서 module을 사용한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Microkernel과 Monolithic kernel을 예를 들자면   &lt;br /&gt;
정부는 작아야한다! 공화당스러운건 &lt;strong&gt;Microkernel&lt;/strong&gt; (kernel이 작으므로)   &lt;br /&gt;
정부는 커야한다! 민주당스러운건 &lt;strong&gt;Monolithic kernel&lt;/strong&gt; (kernel이 많은 일을 해야하므로)&lt;/p&gt;

</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>Operating Systems 1 - Computer Organization</title>
        <link>/2018/04/06/Operating-Systems.html</link>
        <guid isPermaLink="true">/2018/04/06/Operating-Systems.html</guid>
        <description>&lt;h2 id=&quot;what-is-an-operating-system&quot;&gt;What is an Operating System?&lt;/h2&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;Help the user use computer easily (Interface)&lt;/li&gt;
  &lt;li&gt;Help the software use computer resource&lt;/li&gt;
  &lt;li&gt;Help the programmer develop software (API)&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;OS : software와 hardware 사이의 소통을 도움&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;von-neumann-machine&quot;&gt;Von Neumann Machine&lt;/h3&gt;
&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;Pre-Von-Neumann Machine:
    &lt;ul&gt;
      &lt;li&gt;A computer can do only single computation&lt;/li&gt;
      &lt;li&gt;Program = HW, Data in memory&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Von-Neumann Machine
    &lt;ul&gt;
      &lt;li&gt;General purpose computer&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;Program in memory&lt;/strong&gt;, Data in memory&lt;/li&gt;
      &lt;li&gt;Called stored-program architecture&lt;/li&gt;
      &lt;li&gt;Good: re-program easily&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;이전의 폰 노이만 머신에서는 프로그램은 하드웨어에, 데이터는 메모리에 따로 존재했었다면 폰 노이만 머신에서는 프로그램과 데이터가 메모리 안에 들어감으로써 프로그램을 좀 더 쉽게 할 수 있게 되었다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/VNA.png&quot; alt=&quot;VNA&quot; title=&quot;Von Neumann Architecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;registers&quot;&gt;Registers&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;입출력(I/O)을 위한 저장공간
&lt;img src=&quot;/assets/post_img/Registers.png&quot; alt=&quot;Registers&quot; title=&quot;Registers&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Program Counter: 다음 수행할 명령어가 어디인지 주소를 저장&lt;/li&gt;
  &lt;li&gt;Instruction Register: 현재 실행하고 있는 명령어&lt;/li&gt;
  &lt;li&gt;MBR:가져온 주소로 가서 data를 넣음&lt;/li&gt;
  &lt;li&gt;MAR: 가져온 주소를 써 놓는 곳&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;problem-1-of-von-neumann&quot;&gt;Problem 1 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Von Neumann Bottleneck = Bus&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Too much to move over bus: slow (좋은 CPU 여도 Bus도 좋아야 빠르다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Solution: Cache&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Temporary fast memory with recent data/program&lt;/li&gt;
  &lt;li&gt;Code optimization&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Bus에 병목현상이 생기는 문제점을 일시적으로 최근 데이터를 Cache에 저장&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;problem-2-of-von-neumann&quot;&gt;Problem 2 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Program &amp;amp; Data in same memory&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;A program can mess-up instructions in memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Solution: Harvard Architecture&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Separate data and program memory&lt;/li&gt;
  &lt;li&gt;Memory restriction: Prevent accessing memory outside data&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;program과 data가 같은 메모리안에 있게되면 data에 접근할 때 program도 접근이 가능하여 안정성이나 보안도 떨어지게 되고 또한 프로그램은 메모리에 엉망인 명령들을 내려 망가뜨릴 수 있는 가능성이 있다. 아래의 이미지를통해 폰노이만과 하버드의 구조적 차이를 보면 이해가 빠르다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/harvardA.png&quot; alt=&quot;harvardArchitecture&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;problem-3-of-von-neumann&quot;&gt;Problem 3 of Von-Neumann&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Problem: Program &amp;amp; Data over ther same bus&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Different fetch rate, slow bus&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Solution: Harvard Architecture&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Seperate data and program bus&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Problem 2 와 Problem 3 은 같은 문제라고 볼 수 있다. 즉, Program과 Data가 같이 들어있기 때문에 발생된 문제이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;how-a-computer-can-do-many-things-simultaneously&quot;&gt;How a computer can do many things simultaneously?&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Interrupts!! 
컴퓨터가 동시에 여러가지 일을 할 수 있도록 해주는 기능&lt;/p&gt;

&lt;h3 id=&quot;interrupts&quot;&gt;Interrupts&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Provided to improve processor utilization&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;most I/O devices are slower than the processor&lt;/li&gt;
  &lt;li&gt;processor must pause to wait for device&lt;/li&gt;
  &lt;li&gt;wasterful use of the processor&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU가 프로그램을 실행하고 있을 때, 입출력 하드웨어 등의 장치나 또는 예외상황이 발생하여 처리가 필요할 경우 CPU에 알려 처리할 수 있도록 하는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;memory-hierarchy&quot;&gt;Memory Hierarchy&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;p&gt;Major constraints in memory&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;amount&lt;/li&gt;
  &lt;li&gt;speed&lt;/li&gt;
  &lt;li&gt;expense&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Memory must be able to keep up with the processor
Cost of memory must be reasonable in relationship to the other componets&lt;/p&gt;

&lt;h3 id=&quot;the-memory-hierarchy&quot;&gt;The Memory Hierarchy&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/post_img/memoryHierarchy.png&quot; alt=&quot;memoryHierarchy&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위로 갈 수록 빠르고 비쌈, 용량은 적고 속도 빨라짐, 사용 빈도 높아짐&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Going down the hierarchy:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;decreasing cost per bit&lt;/li&gt;
  &lt;li&gt;increasing capacity&lt;/li&gt;
  &lt;li&gt;increasing access time&lt;/li&gt;
  &lt;li&gt;decreasing frequency of access to the memory by the processor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Inboard memory:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Registers&lt;/li&gt;
  &lt;li&gt;Cache&lt;/li&gt;
  &lt;li&gt;Main Memory&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Outboard Storage:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Magnetic Disk, CD-ROM . .&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;principle-of-locality&quot;&gt;Principle of Locality&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;컴퓨터 프로그램의 메모리 접근 패턴이 시 공간적으로 근접한 모습을 보이는 경향이 크다 이것을 근접성의 원칙이라고 한다.
Fact: Memory references by the processor tend to cluster in time and space&lt;/p&gt;

&lt;p&gt;How to exploit it:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Data is organized so that the percentage of accesses to each successively lower level is substantially less than that of the level above&lt;/li&gt;
  &lt;li&gt;Can be applied across more than two levels of memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cache-memory&quot;&gt;Cache memory&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;Invisible to the processors, programmer, OS&lt;br /&gt;
Interacts with other memory management hardware&lt;/p&gt;

&lt;p&gt;Reasons for its existence:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Processor must access memory at least once per instruction cycle&lt;/li&gt;
  &lt;li&gt;Processor execution is limited by memory cycle time&lt;/li&gt;
  &lt;li&gt;Exploit the principle of locality with a small, fast memory&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/post_img/CacheOrganization.png&quot; alt=&quot;Cache&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;위 그림에서와 같이 Main memory에서 Block 단위로 가져오는 것을 알 수있다.
동대문에서 옷을 가져와서 팔려할 때 티한장 가져와서 팔고 또 한장 가져와서 팔고 할 수 없으니 통째(Block)로 가져와서 파는 것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;replacement-algorithm&quot;&gt;Replacement Algorithm&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;캐시에 새로운 Block을 로드할 때 어떤 Block을 대체할 것인지에 대한 알고리즘&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Choose which block to replace when a new block is to be loaded into the cahe&lt;/li&gt;
  &lt;li&gt;Least Recently Used(LRU) Algorithm: 가장 최근에 덜 사용 된 것을 대체시키는 알고리즘&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
      <item>
        <title>MVC, MVP, MVVM</title>
        <link>/2018/04/06/MVC-MVP-MVVM.html</link>
        <guid isPermaLink="true">/2018/04/06/MVC-MVP-MVVM.html</guid>
        <description>&lt;h3 id=&quot;디자인-패턴이란&quot;&gt;디자인 패턴이란?&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;소프트웨어 디자인에서 공통적으로 발생하는 문제를 다루는 보편적이고 반복해서 사용할 수 있는 방법. 이는 다양한 상황에서 사용될 수 있는, 문제를 해결하는 방법에 대한 설명이나 템플릿이다.&lt;/p&gt;

&lt;p&gt;MVC, MVP, MVVM 패턴과 같은 프레임워크가 나오게 된 궁극적인 이유는?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;각 계층을 분리&lt;/strong&gt;시킴으로써 &lt;strong&gt;코드의 재활용성을 높이고 불필요한 중복을 막기위해&lt;/strong&gt; 각 패턴들은 Model과 View의 의존성을 어떻게 제어하느냐에 따라 분류된다.&lt;/p&gt;

&lt;h2 id=&quot;mvcmodel-view-controller&quot;&gt;MVC(Model-View-Controller)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;/assets/img/MVC.png&quot; alt=&quot;MVC&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;모든 입력은 Controller로 들어와 처리된다 -&amp;gt; 입력이 Controller로 들어오면 Controller는 입력에 해당하는 Model을 업데이트한다 -&amp;gt; Model은 해당 데이터를 보여줄 View를 선택하여 보여준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Model: 애플리케이션과 관련된 데이터를 캡슐화하고, 해당 데이터를 조작하고 처리하는 로직과 계산을 하는 부분&lt;/p&gt;

&lt;p&gt;View: 애플리케이션 내에서 사용자가 볼 수있는 부분(화면). 사용자 동작에 응답할 수있다.&lt;/p&gt;

&lt;p&gt;Controller: 하나 이상의 애플리케이션 뷰 객체와 하나 이상의 모델 객체 사이의 코디네이터 또는 중개자 역할을 하는 부분. 뷰로 하여금 모델 객체의 변경사항을 인지하거나, 그 반대의 경우가 가능하도록 하는 매개체. 다른 객체들의 life cycle을 관리하기도 한다.&lt;/p&gt;
</description>
        <pubDate>Fri, 06 Apr 2018 00:00:00 +0900</pubDate>
      </item>
    
  </channel>
</rss>
